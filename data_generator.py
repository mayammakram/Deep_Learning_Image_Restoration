# -*- coding: utf-8 -*-
"""data_generator.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SnnvhX8w71r_11s7GM_LXHbwSfJEhk24

Data Generator
"""

# -*- coding: utf-8 -*-

# =============================================================================
#  @article{zhang2017beyond,
#    title={Beyond a {Gaussian} denoiser: Residual learning of deep {CNN} for image denoising},
#    author={Zhang, Kai and Zuo, Wangmeng and Chen, Yunjin and Meng, Deyu and Zhang, Lei},
#    journal={IEEE Transactions on Image Processing},
#    year={2017},
#    volume={26}, 
#    number={7}, 
#    pages={3142-3155}, 
#  }
# by Kai Zhang (08/2018)
# cskaizhang@gmail.com
# https://github.com/cszn
# modified on the code from https://github.com/husqin/DnCNN-keras
# =============================================================================

# no need to run this code separately


import glob
#import os
import cv2
import numpy as np
from PIL import Image
#from multiprocessing import Pool


patch_size, stride = 40, 10
aug_times = 1
scales = [1, 0.9, 0.8, 0.7]
batch_size = 128

def resize_img(img):
    image = Image.open(img)
    height = image.size[0]
    width = image.size[1]
    # print("Height: ", height, " W: ", width)
    right  = (2040 - width)/2
    # print("Right: ", right)
    left = (2040 - width)/2
    # print("Right: ", right, " L: ", left)
    top = (2040 - height)/2
    bottom = (2040 - height)/2

    #width, height = image.size
    new_width = width + right + left
    new_height = height + top + bottom

    result = Image.new(image.mode, (int(new_width), int(new_height)), (255))
    result.paste(image, (int(left), int(top)))
    return result

def show(x,title=None,cbar=False,figsize=None):
    import matplotlib.pyplot as plt
    plt.figure(figsize=figsize)
    plt.imshow(x,interpolation='nearest',cmap='gray')
    if title:
        plt.title(title)
    if cbar:
        plt.colorbar()
    plt.show()

def data_aug(img, mode=0):

    if mode == 0:
        return img
    elif mode == 1:
        return np.flipud(img)
    elif mode == 2:
        return np.rot90(img)
    elif mode == 3:
        return np.flipud(np.rot90(img))
    elif mode == 4:
        return np.rot90(img, k=2)
    elif mode == 5:
        return np.flipud(np.rot90(img, k=2))
    elif mode == 6:
        return np.rot90(img, k=3)
    elif mode == 7:
        return np.flipud(np.rot90(img, k=3))

def gen_patches(file_name):

    # read image
    img = cv2.imread(file_name, 1)  # RGB scale
    h, w, l = img.shape
    # show(img)
    # print("Height: ", h, " Width: ", w, ", Length: ", l)
    patches = []
    for s in scales:
        h_scaled, w_scaled = int(h*s),int(w*s)
        img_scaled = cv2.resize(img, (h_scaled,w_scaled), interpolation=cv2.INTER_CUBIC)
        # extract patches
        for i in range(0, h_scaled-patch_size+1, stride):
            for j in range(0, w_scaled-patch_size+1, stride):
                x = img_scaled[i:i+patch_size, j:j+patch_size, :]
                
                # temp = x
                # if (i == 0 and j == 0):
                #     print("Here: ", x)
                #patches.append(x)        
                # data aug
                # print("X", x)
                # if np.mean(x) == 255:
                #     continue
                    # print('***************All white************************')
                # else:
                #     print('Not all white')
                # for a in x:
                #     print("a: ", a)
                    # for b in a:
                        # print("B: ", b)
                    # if np.mean(i) != 255.0:
                #         print("Before X: ", i)
                #         print("np.mean:   ----   ", np.mean(i))
                #         print("After: ", i)
                # if np.mean(temp) != 255:
                for k in range(0, aug_times):
                    # if np.mean(temp) == 255:
                    #     continue
                        # x = img_scaled[i:i+patch_size, j:j+patch_size]
                    x_aug = data_aug(x, mode=np.random.randint(0,8))
                    patches.append(x_aug)
    # print("Patches: ", len(patches))
    return patches

def datagenerator(data_dir='data/Train400',verbose=False):
    
    file_list = glob.glob(data_dir+'/*.png')  # get name list of all .png files

    # for i in range(len(file_list)):
    #     result = resize_img(file_list[i])
    #     result.save('data/trained_data/train400_OUT_'+ str(i) + '.png')
    #     print("image printed in data/trained_data/train400_OUT", i, ".png")
    

    # initialize
    data = []
    # resized = []

    # #Generate resized images
    # for i in range(len(file_list)):
    #     resized.append(resize_img(file_list[i]))
    # print("Resized: ", resized)
    # generate patches
    for i in range(len(file_list)):
        # print("Loop: ", i)
        patch = gen_patches(file_list[i])
        data.append(patch)
        if verbose:
            print(str(i+1)+'/'+ str(len(file_list)) + ' is done ^_^')
    data = np.array(data, dtype='uint8')
    # print("Data", data)
    print("Data.shape ", data.shape) #(No images, patches, dimns)
    data = data.reshape((data.shape[0]*data.shape[1],data.shape[2],data.shape[3], data.shape[4])) ## of parameters must be same as prev but change values to 3d
    #data = data.reshape((data.shape[0],data.shape[1],data.shape[3], 1)) ## of parameters must be same as prev but change values to 3d

    print("Data.shape  NEW ", data.shape)
    discard_n = len(data)-len(data)//batch_size*batch_size;
    data = np.delete(data,range(discard_n),axis = 0)
    print('^_^-training data finished-^_^')
    return data

if __name__ == '__main__':   

    data = datagenerator(data_dir='data/Train400')
    # show()
    

#    print('Shape of result = ' + str(res.shape))
#    print('Saving data...')
#    if not os.path.exists(save_dir):
#            os.mkdir(save_dir)
#    np.save(save_dir+'clean_patches.npy', res)
#    print('Done.')
